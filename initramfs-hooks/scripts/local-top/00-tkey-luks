#!/bin/sh
# TKey-LUKS unlock script for initramfs
# This runs during boot in the local-top phase (before cryptroot)
# It handles LUKS unlocking using TKey hardware device

PREREQ=""

prereqs()
{
    echo "$PREREQ"
}

case $1 in
prereqs)
    prereqs
    exit 0
    ;;
esac

# Source cryptsetup functions if available
. /scripts/functions

# Debug logging to kernel log and file
LOG_FILE="/run/tkey-luks.log"
debug_log() {
    # Try to log to file (might not work in early boot)
    echo "[$(date '+%H:%M:%S')] $*" >> "$LOG_FILE" 2>/dev/null || true
    # Also log to console/kmsg for visibility
    echo "TKey-LUKS: $*" >&2
    # Try kernel log
    echo "<6>tkey-luks: $*" > /dev/kmsg 2>/dev/null || true
}

debug_log "=== TKey-LUKS script starting ==="

# Configuration
TKEY_CLIENT="/usr/local/bin/tkey-luks-client"
TKEY_DEVICE_APP="/usr/local/lib/tkey-luks/tkey-luks-device.bin"
TKEY_SERIAL="/dev/ttyACM0"
MAX_WAIT=30
WAIT_INCREMENT=2

# Logging functions
log_tkey() {
    debug_log "$1"
    log_begin_msg "TKey-LUKS: $1"
}

log_tkey_success() {
    debug_log "SUCCESS: $1"
    log_success_msg "TKey-LUKS: $1"
}

log_tkey_failure() {
    debug_log "FAILURE: $1"
    log_failure_msg "TKey-LUKS: $1"
}

# Wait for TKey device to appear
wait_for_tkey() {
    debug_log "Waiting for TKey device at $TKEY_SERIAL..."
    log_tkey "Waiting for TKey device..."
    
    local waited=0
    while [ $waited -lt $MAX_WAIT ]; do
        if [ -e "$TKEY_SERIAL" ]; then
            debug_log "TKey device found!"
            log_tkey_success "TKey device found at $TKEY_SERIAL"
            return 0
        fi
        
        sleep $WAIT_INCREMENT
        waited=$((waited + WAIT_INCREMENT))
        
        # Show progress
        if [ $((waited % 6)) -eq 0 ]; then
            echo "Still waiting for TKey... ($waited/${MAX_WAIT}s)"
        fi
    done
    
    log_tkey_failure "TKey device not found after ${MAX_WAIT}s"
    return 1
}

# Check if TKey client and device app are available
check_tkey_components() {
    debug_log "Checking TKey components..."
    debug_log "  Client: $TKEY_CLIENT"
    debug_log "  Device app: $TKEY_DEVICE_APP"
    
    if [ ! -x "$TKEY_CLIENT" ]; then
        debug_log "Client not found or not executable"
        log_tkey_failure "TKey client not found: $TKEY_CLIENT"
        return 1
    fi
    
    if [ ! -f "$TKEY_DEVICE_APP" ]; then
        debug_log "Device app not found"
        log_tkey_failure "TKey device app not found: $TKEY_DEVICE_APP"
        return 1
    fi
    
    debug_log "All components present"
    
    return 0
}

# Prompt for challenge (what user thinks is "password")
prompt_for_challenge() {
    local prompt="${1:-Enter TKey challenge}"
    local challenge=""
    
    # Use plymouth if available (graphical boot)
    if command -v plymouth >/dev/null 2>&1 && plymouth --ping 2>/dev/null; then
        challenge=$(plymouth ask-for-password --prompt="$prompt")
    else
        # Fallback to console input
        printf "%s: " "$prompt" >&2
        stty -echo
        read -r challenge
        stty echo
        printf "\n" >&2
    fi
    
    echo "$challenge"
}

# Derive key using TKey with challenge
derive_key_with_tkey() {
    local challenge="$1"
    local output_file="$2"
    
    log_tkey "Loading device app and deriving key..."
    
    # Run TKey client with challenge
    # The client will:
    #   1. Derive USS from password using PBKDF2 (improved security!)
    #   2. Load device app to TKey with derived USS
    #   3. Send challenge (same password used for USS)
    #   4. Wait for physical touch (security feature)
    #   5. Derive 64-byte LUKS key
    #   6. Output key to file
    #
    # This ensures password is used in TWO layers:
    #   - USS derivation (affects CDI)
    #   - Challenge data (affects BLAKE2b)
    
    if echo "$challenge" | "$TKEY_CLIENT" \
        --device "$TKEY_SERIAL" \
        --device-app "$TKEY_DEVICE_APP" \
        --output "$output_file" \
        --challenge-from-stdin \
        --derive-uss \
        2>/tmp/tkey-error.log; then
        
        log_tkey_success "Key derived successfully"
        return 0
    else
        log_tkey_failure "Key derivation failed"
        if [ -f /tmp/tkey-error.log ]; then
            cat /tmp/tkey-error.log >&2
        fi
        return 1
    fi
}

# Unlock LUKS device with TKey-derived key
unlock_luks_with_tkey() {
    local luks_device="$1"
    local mapper_name="$2"
    local challenge="$3"
    local keyfile="/tmp/tkey-key-$$.bin"
    
    # Derive key from TKey
    if ! derive_key_with_tkey "$challenge" "$keyfile"; then
        rm -f "$keyfile"
        return 1
    fi
    
    # Attempt to unlock LUKS volume
    log_tkey "Unlocking LUKS device: $luks_device"
    
    if cryptsetup luksOpen "$luks_device" "$mapper_name" --key-file="$keyfile" 2>/tmp/luks-error.log; then
        log_tkey_success "LUKS device unlocked successfully"
        rm -f "$keyfile"
        return 0
    else
        log_tkey_failure "Failed to unlock LUKS device"
        if [ -f /tmp/luks-error.log ]; then
            cat /tmp/luks-error.log >&2
        fi
        rm -f "$keyfile"
        return 1
    fi
}

# Main unlock handler
tkey_luks_unlock() {
    local retry_count=0
    local max_retries=3
    
    debug_log "tkey_luks_unlock() called"
    echo "TKey-LUKS: Starting unlock process..." >&2
    
    # Check if TKey components are available
    debug_log "Checking TKey components..."
    if ! check_tkey_components; then
        echo "TKey-LUKS disabled: components not available" >&2
        return 1
    fi
    
    # Wait for TKey device
    debug_log "Waiting for TKey device..."
    if ! wait_for_tkey; then
        echo "TKey-LUKS disabled: device not found" >&2
        echo "Will fall back to standard password prompt" >&2
        return 1
    fi
    
    # Find LUKS devices that need unlocking
    # Read from /cryptroot/crypttab (generated from /etc/crypttab with initramfs option)
    local luks_device=""
    local mapper_name=""
    
    debug_log "Looking for LUKS devices to unlock..."
    
    # The crypttab is copied to /cryptroot/crypttab in initramfs
    # Format: target source keyfile options
    if [ -f /cryptroot/crypttab ]; then
        debug_log "Reading /cryptroot/crypttab"
        while read target source keyfile options; do
            # Skip comments and empty lines
            case "$target" in
                ""|\#*) continue ;;
            esac
            
            debug_log "Found crypttab entry: $target $source $keyfile $options"
            
            # Check if initramfs option is present
            if ! echo "$options" | grep -q "initramfs"; then
                debug_log "Skipping $target - no initramfs option"
                continue
            fi
            
            # Use the first LUKS entry with initramfs option
            mapper_name="$target"
            
            # Source can be UUID=... or /dev/...
            if echo "$source" | grep -q "UUID="; then
                uuid=$(echo "$source" | sed 's/UUID=//')
                luks_device="/dev/disk/by-uuid/$uuid"
                debug_log "Resolved UUID to: $luks_device"
            else
                luks_device="$source"
            fi
            
            break  # Only handle first device for now
        done < /cryptroot/crypttab
    else
        debug_log "/cryptroot/crypttab not found"
    fi
    
    # Fallback: try to find from /proc/cmdline
    if [ -z "$luks_device" ]; then
        debug_log "No cryptroot config, checking /proc/cmdline"
        for param in $(cat /proc/cmdline); do
            case "$param" in
                cryptdevice=*)
                    luks_device="${param#cryptdevice=}"
                    mapper_name="${luks_device##*:}"
                    luks_device="${luks_device%%:*}"
                    debug_log "Found from cmdline: $luks_device -> $mapper_name"
                    ;;
            esac
        done
    fi
    
    # If still no device found, skip TKey unlock
    if [ -z "$luks_device" ] || [ -z "$mapper_name" ]; then
        debug_log "No LUKS device found to unlock"
        log_tkey "No LUKS device configured for unlock"
        return 1
    fi
    
    debug_log "Target: $luks_device -> /dev/mapper/$mapper_name"
    log_tkey "Target device: $mapper_name"
    
    # Retry loop for challenge/unlock
    while [ $retry_count -lt $max_retries ]; do
        # Prompt for challenge
        if [ $retry_count -eq 0 ]; then
            challenge=$(prompt_for_challenge "TKey challenge for $mapper_name")
        else
            challenge=$(prompt_for_challenge "TKey challenge (attempt $((retry_count + 1))/$max_retries)")
        fi
        
        # Check if user wants to skip TKey
        if [ "$challenge" = "skip" ] || [ "$challenge" = "SKIP" ]; then
            log_tkey "User requested skip - falling back to password"
            return 1
        fi
        
        # Attempt unlock with TKey
        if unlock_luks_with_tkey "$luks_device" "$mapper_name" "$challenge"; then
            return 0
        fi
        
        retry_count=$((retry_count + 1))
        echo "Unlock failed. Please try again or type 'skip' for password fallback."
        sleep 1
    done
    
    log_tkey_failure "Max retries reached. Falling back to password."
    return 1
}

# Only run if not already unlocked and TKey is configured
# Check if we should handle this
debug_log "TKEY_LUKS_ENABLED=${TKEY_LUKS_ENABLED:-(unset)}"
debug_log "Checking if TKey unlock should run..."

# Always run unless explicitly disabled
if [ "$TKEY_LUKS_ENABLED" != "no" ] && [ "$TKEY_LUKS_ENABLED" != "0" ]; then
    debug_log "Starting TKey unlock attempt..."
    echo "TKey-LUKS: Attempting unlock..." >&2
    
    # Attempt TKey unlock
    # If it fails, initramfs will continue to standard cryptsetup password prompt
    if tkey_luks_unlock; then
        debug_log "TKey unlock succeeded!"
        echo "TKey-LUKS: Unlock successful!" >&2
    else
        debug_log "TKey unlock failed or skipped, falling back to password"
        echo "TKey-LUKS: Falling back to password prompt" >&2
    fi
else
    debug_log "TKey disabled by TKEY_LUKS_ENABLED variable"
    echo "TKey-LUKS: Disabled (TKEY_LUKS_ENABLED=$TKEY_LUKS_ENABLED)" >&2
fi

debug_log "=== TKey-LUKS script finished ==="
